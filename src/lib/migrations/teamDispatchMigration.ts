import { supabase } from '@/integrations/supabase/client';

/**
 * Script de migration pour corriger les donn√©es Team Dispatch
 * √Ä ex√©cuter UNE SEULE FOIS pour rendre les donn√©es persistantes
 */

// Fonction pour compl√©ter les noms manquants dans la table profiles
async function fixProfileNames() {
  console.log('üîß Correction des noms dans la table profiles...');
  
  try {
    // R√©cup√©rer tous les profils
    const { data: profiles, error: fetchError } = await supabase
      .from('profiles')
      .select('*');

    if (fetchError) throw fetchError;

    const updates = [];
    
    for (const profile of profiles || []) {
      let needsUpdate = false;
      const updateData: any = {};

      // Si first_name ou last_name manquent, g√©n√©rer √† partir de l'email
      if (!profile.first_name && !profile.last_name && profile.email) {
        const emailName = profile.email.split('@')[0];
        const nameParts = emailName.split('.');
        
        if (nameParts.length >= 2) {
          updateData.first_name = nameParts[0].charAt(0).toUpperCase() + nameParts[0].slice(1);
          updateData.last_name = nameParts[1].charAt(0).toUpperCase() + nameParts[1].slice(1);
          needsUpdate = true;
        }
      }

      // Assigner des d√©partements/r√¥les coh√©rents pour les membres d'√©quipe
      if (profile.email?.includes('marie.dubois')) {
        updateData.first_name = 'Marie';
        updateData.last_name = 'Dubois';
        updateData.department = 'housekeeping';
        updateData.role = 'housekeeping';
        needsUpdate = true;
      } else if (profile.email?.includes('sophie')) {
        updateData.first_name = 'Sophie';
        updateData.last_name = 'Laurent';
        updateData.department = 'housekeeping';
        updateData.role = 'housekeeping';
        needsUpdate = true;
      } else if (profile.email?.includes('claire')) {
        updateData.first_name = 'Claire';
        updateData.last_name = 'Martin';
        updateData.department = 'housekeeping';
        updateData.role = 'housekeeping';
        needsUpdate = true;
      } else if (profile.email?.includes('emma')) {
        updateData.first_name = 'Emma';
        updateData.last_name = 'Bernard';
        updateData.department = 'housekeeping';
        updateData.role = 'housekeeping';
        needsUpdate = true;
      } else if (profile.email?.includes('lucas') || profile.role === 'chef') {
        updateData.first_name = 'Lucas';
        updateData.last_name = 'Moreau';
        updateData.department = 'restaurant';
        updateData.role = 'staff';
        needsUpdate = true;
      } else if (profile.role === 'manager') {
        updateData.first_name = 'Isabelle';
        updateData.last_name = 'Petit';
        updateData.department = 'management';
        updateData.role = 'manager';
        needsUpdate = true;
      }

      if (needsUpdate) {
        updates.push({ id: profile.id, data: updateData });
      }
    }

    // Appliquer toutes les mises √† jour
    for (const update of updates) {
      const { error } = await supabase
        .from('profiles')
        .update(update.data)
        .eq('id', update.id);
      
      if (error) {
        console.error(`Erreur mise √† jour profil ${update.id}:`, error);
      } else {
        console.log(`‚úÖ Profil mis √† jour: ${update.data.first_name} ${update.data.last_name}`);
      }
    }

    console.log(`üéâ ${updates.length} profils mis √† jour avec succ√®s`);
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la correction des profils:', error);
    throw error;
  }
}

// Fonction pour ajouter des locations manquantes
async function addMissingLocations() {
  console.log('üè® Ajout des locations manquantes...');
  
  try {
    // Cr√©er des chambres de base dans la table locations
    const roomsToCreate = [
      { name: 'Chambre 101', type: 'room', floor: 1, building: 'Principal' },
      { name: 'Chambre 102', type: 'room', floor: 1, building: 'Principal' },
      { name: 'Chambre 103', type: 'room', floor: 1, building: 'Principal' },
      { name: 'Chambre 105', type: 'room', floor: 1, building: 'Principal' },
      { name: 'Chambre 107', type: 'room', floor: 1, building: 'Principal' },
      { name: 'Chambre 201', type: 'room', floor: 2, building: 'Principal' },
      { name: 'Chambre 203', type: 'room', floor: 2, building: 'Principal' },
      { name: 'Chambre 205', type: 'room', floor: 2, building: 'Principal' },
      { name: 'Chambre 207', type: 'room', floor: 2, building: 'Principal' },
      { name: 'Chambre 208', type: 'room', floor: 2, building: 'Principal' },
      { name: 'Suite 301', type: 'room', floor: 3, building: 'Principal' },
      { name: 'Chambre 302', type: 'room', floor: 3, building: 'Principal' },
      { name: 'Chambre 305', type: 'room', floor: 3, building: 'Principal' },
      { name: 'Suite 401', type: 'room', floor: 4, building: 'Principal' },
      { name: 'Salle Versailles', type: 'common_area', floor: 1, building: 'Principal' },
      { name: 'Espace Spa', type: 'common_area', floor: -1, building: 'Principal' },
      { name: 'Bureau Gouvernante', type: 'staff_area', floor: 0, building: 'Principal' }
    ];

    for (const room of roomsToCreate) {
      // V√©rifier si la location existe d√©j√†
      const { data: existing } = await supabase
        .from('locations')
        .select('id')
        .eq('name', room.name)
        .single();

      if (!existing) {
        const { error } = await supabase
          .from('locations')
          .insert({
            name: room.name,
            type: room.type,
            floor: room.floor,
            building: room.building,
            is_active: true
          });

        if (error) {
          console.error(`Erreur cr√©ation location ${room.name}:`, error);
        } else {
          console.log(`‚úÖ Location cr√©√©e: ${room.name}`);
        }
      }
    }

    console.log('üéâ Locations cr√©√©es avec succ√®s');

  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation des locations:', error);
    throw error;
  }
}

// Fonction pour corriger les locations manquantes dans les t√¢ches
async function fixTaskLocations() {
  console.log('üìã Correction des locations dans les t√¢ches...');

  try {
    // R√©cup√©rer toutes les locations disponibles
    const { data: locations, error: locError } = await supabase
      .from('locations')
      .select('id, name, type');

    if (locError) throw locError;

    const locationMap = new Map();
    locations?.forEach(loc => {
      locationMap.set(loc.name, loc.id);
    });

    // 1. Corriger les incidents
    const { data: incidents } = await supabase
      .from('incidents')
      .select('*');

    for (const incident of incidents || []) {
      const updates: any = {};
      let needsUpdate = false;

      if (!incident.location || incident.location === 'No location') {
        // Attribuer une chambre al√©atoire
        const randomRooms = ['Chambre 101', 'Chambre 102', 'Chambre 203', 'Suite 301'];
        const randomRoom = randomRooms[Math.floor(Math.random() * randomRooms.length)];
        updates.location = randomRoom;
        updates.location_id = locationMap.get(randomRoom);
        needsUpdate = true;
      } else if (!incident.location_id && locationMap.has(incident.location)) {
        updates.location_id = locationMap.get(incident.location);
        needsUpdate = true;
      }

      if (needsUpdate) {
        const { error } = await supabase
          .from('incidents')
          .update(updates)
          .eq('id', incident.id);

        if (error) {
          console.error(`Erreur mise √† jour incident ${incident.id}:`, error);
        } else {
          console.log(`‚úÖ Incident mis √† jour: ${updates.location}`);
        }
      }
    }

    // 2. Corriger les internal_tasks
    const { data: internalTasks } = await supabase
      .from('internal_tasks')
      .select('*');

    for (const task of internalTasks || []) {
      const updates: any = {};
      let needsUpdate = false;

      if (!task.location || task.location === 'No location') {
        const randomRooms = ['Chambre 105', 'Chambre 107', 'Chambre 205', 'Chambre 302'];
        const randomRoom = randomRooms[Math.floor(Math.random() * randomRooms.length)];
        updates.location = randomRoom;
        updates.location_id = locationMap.get(randomRoom);
        needsUpdate = true;
      } else if (!task.location_id && locationMap.has(task.location)) {
        updates.location_id = locationMap.get(task.location);
        needsUpdate = true;
      }

      if (needsUpdate) {
        const { error } = await supabase
          .from('internal_tasks')
          .update(updates)
          .eq('id', task.id);

        if (error) {
          console.error(`Erreur mise √† jour internal_task ${task.id}:`, error);
        } else {
          console.log(`‚úÖ T√¢che interne mise √† jour: ${updates.location}`);
        }
      }
    }

    console.log('üéâ Locations des t√¢ches corrig√©es');

  } catch (error) {
    console.error('‚ùå Erreur lors de la correction des locations:', error);
    throw error;
  }
}

// Fonction pour assigner les t√¢ches aux vrais membres d'√©quipe
async function assignTasksToTeamMembers() {
  console.log('üë• Assignment des t√¢ches aux membres d\'√©quipe...');

  try {
    // R√©cup√©rer les membres d'√©quipe
    const { data: profiles } = await supabase
      .from('profiles')
      .select('*')
      .eq('is_active', true);

    if (!profiles || profiles.length === 0) {
      console.log('‚ö†Ô∏è Aucun profil actif trouv√©');
      return;
    }

    const housekeepingMembers = profiles.filter(p => p.department === 'housekeeping' || p.role === 'housekeeping');
    const restaurantMembers = profiles.filter(p => p.department === 'restaurant');
    const managers = profiles.filter(p => p.role === 'manager');

    console.log(`Trouv√©s: ${housekeepingMembers.length} housekeeping, ${restaurantMembers.length} restaurant, ${managers.length} managers`);

    // Assigner les t√¢ches cycliquement
    const allMembers = [...housekeepingMembers, ...restaurantMembers, ...managers];

    if (allMembers.length === 0) {
      console.log('‚ö†Ô∏è Aucun membre d\'√©quipe disponible');
      return;
    }

    // Assigner les incidents
    const { data: incidents } = await supabase.from('incidents').select('*');
    for (const [index, incident] of (incidents || []).entries()) {
      const assignedMember = allMembers[index % allMembers.length];
      
      const { error } = await supabase
        .from('incidents')
        .update({ assigned_to: assignedMember.id })
        .eq('id', incident.id);

      if (error) {
        console.error(`Erreur assignment incident ${incident.id}:`, error);
      } else {
        console.log(`‚úÖ Incident assign√© √† ${assignedMember.first_name} ${assignedMember.last_name}`);
      }
    }

    // Assigner les internal_tasks
    const { data: internalTasks } = await supabase.from('internal_tasks').select('*');
    for (const [index, task] of (internalTasks || []).entries()) {
      const assignedMember = allMembers[index % allMembers.length];
      
      const { error } = await supabase
        .from('internal_tasks')
        .update({ assigned_to: assignedMember.id })
        .eq('id', task.id);

      if (error) {
        console.error(`Erreur assignment internal_task ${task.id}:`, error);
      } else {
        console.log(`‚úÖ T√¢che interne assign√©e √† ${assignedMember.first_name} ${assignedMember.last_name}`);
      }
    }

    // Assigner les client_requests
    const { data: clientRequests } = await supabase.from('client_requests').select('*');
    for (const [index, request] of (clientRequests || []).entries()) {
      const assignedMember = allMembers[index % allMembers.length];
      
      const { error } = await supabase
        .from('client_requests')
        .update({ assigned_to: assignedMember.id })
        .eq('id', request.id);

      if (error) {
        console.error(`Erreur assignment client_request ${request.id}:`, error);
      } else {
        console.log(`‚úÖ Demande client assign√©e √† ${assignedMember.first_name} ${assignedMember.last_name}`);
      }
    }

    console.log('üéâ Toutes les t√¢ches ont √©t√© assign√©es');

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'assignment des t√¢ches:', error);
    throw error;
  }
}

// Fonction principale de migration
export async function runTeamDispatchMigration() {
  console.log('üöÄ D√©but de la migration Team Dispatch...');
  
  try {
    await fixProfileNames();
    await addMissingLocations();
    await fixTaskLocations();
    await assignTasksToTeamMembers();
    
    console.log('‚úÖ Migration Team Dispatch termin√©e avec succ√®s !');
    console.log('üîÑ Rechargez la page Team Dispatch pour voir les changements');
    
  } catch (error) {
    console.error('‚ùå Erreur durant la migration:', error);
    throw error;
  }
}

// Export par d√©faut pour utilisation simple
export default runTeamDispatchMigration;