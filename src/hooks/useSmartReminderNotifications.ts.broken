import { useState, useEffect, useCallback, useRef } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport getReminders from '@/lib/actions/getReminders';\n\ninterface ReminderData {\n  id: string;\n  title: string;\n  message?: string;\n  task_id?: string;\n  remind_at: string;\n  status: string;\n  // Pour les checklists\n  checklist_title?: string;\n  task_title?: string;\n}\n\ninterface UseSmartReminderNotificationsReturn {\n  currentReminder: ReminderData | null;\n  isReminderVisible: boolean;\n  closeReminder: () => void;\n  snoozeReminder: (reminderID: string, minutes: number) => Promise<void>;\n  markReminderDone: (reminderID: string) => Promise<void>;\n}\n\nexport function useSmartReminderNotifications(): UseSmartReminderNotificationsReturn {\n  const [currentReminder, setCurrentReminder] = useState<ReminderData | null>(null);\n  const [isReminderVisible, setIsReminderVisible] = useState(false);\n  const [shownReminders, setShownReminders] = useState<Set<string>>(new Set());\n  \n  // Stocker les timeouts pour pouvoir les annuler\n  const timeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());\n\n  // Fonction pour récupérer et programmer les reminders de la prochaine heure\n  const scheduleUpcomingReminders = useCallback(async () => {\n    try {\n      const now = new Date();\n      const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);\n      \n      console.log('🕐 Programmation des reminders pour la prochaine heure...');\n      \n      // Récupérer tous les reminders actifs\n      const allReminders = await getReminders({ limit: 100 });\n      \n      // Filtrer ceux de la prochaine heure qui ne sont pas déjà montrés\n      const upcomingReminders = allReminders.filter((reminder: ReminderData) => {\n        const reminderTime = new Date(reminder.remind_at);\n        const isPending = reminder.status === 'pending' || !reminder.status;\n        const isInNextHour = reminderTime >= now && reminderTime <= oneHourLater;\n        const notAlreadyShown = !shownReminders.has(reminder.id);\n        \n        return isPending && isInNextHour && notAlreadyShown;\n      });\n      \n      console.log(`📅 ${upcomingReminders.length} reminders trouvés pour la prochaine heure`);\n      \n      // Annuler les anciens timeouts\n      timeoutsRef.current.forEach((timeout) => clearTimeout(timeout));\n      timeoutsRef.current.clear();\n      \n      // Programmer chaque reminder avec setTimeout\n      upcomingReminders.forEach((reminder: ReminderData) => {\n        const reminderTime = new Date(reminder.remind_at);\n        const delay = reminderTime.getTime() - now.getTime();\n        \n        if (delay > 0) {\n          console.log(`⏰ Programmation reminder \"${reminder.title}\" dans ${Math.round(delay/1000/60)}min`);\n          \n          const timeoutId = setTimeout(async () => {\n            await showReminder(reminder);\n            timeoutsRef.current.delete(reminder.id);\n          }, delay);\n          \n          timeoutsRef.current.set(reminder.id, timeoutId);\n        }\n      });\n      \n    } catch (error) {\n      console.error('❌ Erreur programmation reminders:', error);\n    }\n  }, [shownReminders]);\n  \n  // Fonction pour enrichir et afficher un reminder\n  const showReminder = useCallback(async (reminder: ReminderData) => {\n    try {\n      console.log('🔔 Déclenchement du reminder:', reminder.title);\n      \n      // Vérifier que le reminder n'est pas déjà affiché\n      if (isReminderVisible || shownReminders.has(reminder.id)) {\n        return;\n      }\n      \n      // Enrichir avec les données de task/checklist si nécessaire\n      if (reminder.task_id) {\n        try {\n          const { data: taskData, error: taskError } = await supabase\n            .from('task')\n            .select('title, type')\n            .eq('id', reminder.task_id)\n            .single();\n\n          if (!taskError && taskData) {\n            reminder.task_title = taskData.title;\n            \n            // Si c'est une checklist, récupérer les détails\n            if (taskData.type === 'checklist') {\n              const { data: checklistData, error: checklistError } = await supabase\n                .from('checklists')\n                .select('title')\n                .eq('task_id', reminder.task_id)\n                .single();\n              \n              if (!checklistError && checklistData) {\n                reminder.checklist_title = checklistData.title;\n              }\n            }\n          }\n        } catch (error) {\n          console.warn('⚠️ Erreur récupération détails task:', error);\n        }\n      }\n      \n      setCurrentReminder(reminder);\n      setIsReminderVisible(true);\n      \n      // Marquer comme montré\n      setShownReminders(prev => new Set([...prev, reminder.id]));\n      \n    } catch (error) {\n      console.error('❌ Erreur affichage reminder:', error);\n    }\n  }, [isReminderVisible, shownReminders]);\n\n  // Fonction pour fermer le popup\n  const closeReminder = useCallback(() => {\n    setIsReminderVisible(false);\n    setCurrentReminder(null);\n  }, []);\n\n  // Fonction pour snoozer un reminder\n  const snoozeReminder = useCallback(async (reminderID: string, minutes: number) => {\n    try {\n      const newRemindAt = new Date();\n      newRemindAt.setMinutes(newRemindAt.getMinutes() + minutes);\n\n      console.log(`💤 Snooze reminder ${reminderID} pour ${minutes} minutes`);\n\n      const { error } = await supabase\n        .from('reminders')\n        .update({ \n          remind_at: newRemindAt.toISOString(),\n          status: 'snoozed',\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', reminderID);\n\n      if (error) throw error;\n\n      console.log('✅ Reminder snoozé avec succès');\n      \n      // Retirer de la liste des montrés pour permettre le re-déclenchement\n      setShownReminders(prev => {\n        const updated = new Set(prev);\n        updated.delete(reminderID);\n        return updated;\n      });\n      \n      // Annuler le timeout s'il existe\n      const existingTimeout = timeoutsRef.current.get(reminderID);\n      if (existingTimeout) {\n        clearTimeout(existingTimeout);\n        timeoutsRef.current.delete(reminderID);\n      }\n\n    } catch (error) {\n      console.error('❌ Erreur snooze reminder:', error);\n    }\n  }, []);\n\n  // Fonction pour marquer un reminder comme terminé\n  const markReminderDone = useCallback(async (reminderID: string) => {\n    try {\n      console.log(`✅ Marquage reminder ${reminderID} comme terminé`);\n\n      const { error } = await supabase\n        .from('reminders')\n        .update({ \n          status: 'completed',\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', reminderID);\n\n      if (error) throw error;\n\n      console.log('✅ Reminder marqué comme terminé');\n      \n      // Annuler le timeout s'il existe\n      const existingTimeout = timeoutsRef.current.get(reminderID);\n      if (existingTimeout) {\n        clearTimeout(existingTimeout);\n        timeoutsRef.current.delete(reminderID);\n      }\n\n    } catch (error) {\n      console.error('❌ Erreur marquage reminder terminé:', error);\n    }\n  }, []);\n\n  // Effet principal : programmer les reminders toutes les heures\n  useEffect(() => {\n    // Programmation initiale\n    scheduleUpcomingReminders();\n    \n    // Programmer toutes les heures (polling intelligent)\n    const hourlyInterval = setInterval(scheduleUpcomingReminders, 60 * 60 * 1000);\n    \n    console.log('🚀 Système de reminders intelligent activé (programmation horaire)');\n    \n    return () => {\n      clearInterval(hourlyInterval);\n      \n      // Nettoyer tous les timeouts en cours\n      timeoutsRef.current.forEach((timeout) => clearTimeout(timeout));\n      timeoutsRef.current.clear();\n      \n      console.log('🛑 Système de reminders intelligent désactivé');\n    };\n  }, [scheduleUpcomingReminders]);\n  \n  // Reset de la liste des montrés toutes les 12 heures\n  useEffect(() => {\n    const resetInterval = setInterval(() => {\n      console.log('🔄 Reset des reminders montrés');\n      setShownReminders(new Set());\n    }, 12 * 60 * 60 * 1000);\n    \n    return () => clearInterval(resetInterval);\n  }, []);\n\n  return {\n    currentReminder,\n    isReminderVisible,\n    closeReminder,\n    snoozeReminder,\n    markReminderDone,\n  };\n}